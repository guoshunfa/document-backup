(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{397:function(n,t,a){"use strict";a.r(t);var e=a(44),i=Object(e.a)({},(function(){var n=this,t=n.$createElement,a=n._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h1",{attrs:{id:"spring-参数校验器-validator"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#spring-参数校验器-validator"}},[n._v("#")]),n._v(" Spring 参数校验器（Validator）")]),n._v(" "),a("p",[n._v("应用在执行业务逻辑之前，必须通过校验保证接受到的输入数据是合法正确的，但很多时候同样的校验出现了多次，在不同的层，不同的方法上，导致代码冗余，浪费时间，违反DRY原则。")]),n._v(" "),a("ul",[a("li",[n._v("每一个控制器都要校验")]),n._v(" "),a("li",[n._v("过多的校验参数会导致代码太长")]),n._v(" "),a("li",[n._v("代码的复用率太差，同样的代码如果出现多次，在业务越来越复杂的情况下，维护成本呈指数上升。")])]),n._v(" "),a("p",[n._v("可以考虑把校验的代码封装起来，来解决出现的这些问题。")]),n._v(" "),a("h2",{attrs:{id:"jsr-303"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jsr-303"}},[n._v("#")]),n._v(" JSR-303")]),n._v(" "),a("p",[n._v("JSR-303是Java为Bean数据合法性校验提供的标准框架，它定义了一套可标注在成员变量，属性方法上的校验注解。\nHibernate Validation提供了这套标准的实现，在我们引入Spring Boot web starter或者Spring boot starter validation的时候，默认会引入Hibernate Validation。")]),n._v(" "),a("h2",{attrs:{id:"用法实例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#用法实例"}},[n._v("#")]),n._v(" 用法实例")]),n._v(" "),a("p",[n._v("说了这么多废话，上代码。")]),n._v(" "),a("p",[n._v("1、引入SpringBoot项目")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("      <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.hibernate.validator</groupId>\n            <artifactId>hibernate-validator</artifactId>\n        </dependency>\n       \x3c!-- 引入lomhok --\x3e \n       <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n        </dependency>        \n")])])]),a("p",[n._v("2、编写校验对象")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('@Data\npublic class User {\n    // 名字不允许为空，并且名字的长度在2位到30位之间\n    // 如果名字的长度校验不通过，那么提示错误信息\n    @NotNull\n    @Size(min=2, max=30,message = "请检查名字的长度是否有问题")\n    private String name;\n\n    // 不允许为空，并且年龄的最小值为18\n    @NotNull\n    @Min(18)\n    private Integer age;\n}\n')])])]),a("p",[n._v("3、创建控制器")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('@SpringBootApplication\n@RestController\npublic class UserApplication{\n    public static void main(String[] args) {\n        SpringApplication.run(UserApplication.class,args);\n    }\n    \n    // 1. 要校验的参数前，加上@Valid注解\n    // 2. 紧随其后的，跟上一个BindingResult来存储校验信息\n    @RequestMapping("/test1")\n    public Object test1(\n            @Valid User user,\n            BindingResult bindingResult\n    ) {\n        //如果检验出了问题，就返回错误信息\n        // 这里我们返回的是全部的错误信息，实际中可根据bindingResult的方法根据需要返回自定义的信息。\n        // 通常的解决方案为：JSR-303 + 全局ExceptionHandler\n        if (bindingResult.hasErrors()){\n            return bindingResult.getAllErrors();\n        }\n        return "OK";\n    }\n    \n}\n')])])]),a("h2",{attrs:{id:"常见的校验注解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常见的校验注解"}},[n._v("#")]),n._v(" 常见的校验注解")]),n._v(" "),a("blockquote",[a("p",[n._v("@Null 被注释的元素必须为 null")]),a("p",[n._v("\n@NotNull 被注释的元素必须不为 null")]),a("p",[n._v("\n@AssertTrue 被注释的元素必须为 true")]),a("p",[n._v("\n@AssertFalse 被注释的元素必须为 false")]),a("p",[n._v("\n@Min(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值")]),a("p",[n._v("\n@Max(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值")]),a("p",[n._v("\n@DecimalMin(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值")]),a("p",[n._v("\n@DecimalMax(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值")]),a("p",[n._v("\n@Size(max=, min=) 被注释的元素的大小必须在指定的范围内")]),a("p",[n._v("\n@Digits (integer, fraction) 被注释的元素必须是一个数字，其值必须在可接受的范围内")]),a("p",[n._v("\n@Past 被注释的元素必须是一个过去的日期")]),a("p",[n._v("\n@Future 被注释的元素必须是一个将来的日期")]),a("p",[n._v("\n@Pattern(regex=,flag=) 被注释的元素必须符合指定的正则表达式")]),a("p"),a("p")]),n._v(" "),a("blockquote",[a("p",[a("strong",[n._v("Hibernate Validator提供的校验注解：")])]),a("p",[n._v("\n@NotBlank(message =) 验证字符串非null，且长度必须大于0")]),a("p",[n._v("\n@Email 被注释的元素必须是电子邮箱地址")]),a("p",[n._v("\n@Length(min=,max=) 被注释的字符串的大小必须在指定的范围内")]),a("p",[n._v("\n@NotEmpty 被注释的字符串的必须非空")]),a("p",[n._v("\n@Range(min=,max=,message=) 被注释的元素必须在合适的范围内")]),a("p")]),n._v(" "),a("h2",{attrs:{id:"自定义校验注解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#自定义校验注解"}},[n._v("#")]),n._v(" 自定义校验注解")]),n._v(" "),a("p",[n._v("有时候，第三方库中并没有我们想要的校验类型，好在系统提供了很好的扩展能力，我们可以自定义检验。\n比如，我们想校验用户的手机格式，写手机号码校验器")]),n._v(" "),a("p",[n._v("1、编写校验注解")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('// 我们可以直接拷贝系统内的注解如@Min，复制到我们新的注解中，然后根据需要修改。\n@Target({METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER})\n@Retention(RUNTIME)\n@Documented\n//注解的实现类。\n@Constraint(validatedBy = {IsMobileValidator.class})\npublic @interface IsMobile {\n    //校验错误的默认信息\n    String message() default "手机号码格式有问题";\n\n    //是否强制校验\n    boolean isRequired() default false;\n    \n    Class<?>[] groups() default {};\n\n    Class<? extends Payload>[] payload() default {};\n}\n')])])]),a("p",[n._v("2、编写具体的实现类\n我们知道注解只是一个标记，真正的逻辑还要在特定的类中实现，上一步的注解指定了实现校验功能的类为IsMobileValidator。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('// 自定义注解一定要实现ConstraintValidator接口奥，里面的两个参数\n// 第一个为 具体要校验的注解\n// 第二个为 校验的参数类型\npublic class IsMobileValidator implements ConstraintValidator<IsMobile, String> {\n\n    private boolean required = false;\n\n    private static final Pattern mobile_pattern = Pattern.compile("1\\\\d{10}");\n    //工具方法，判断是否是手机号\n    public static boolean isMobile(String src) {\n        if (StringUtils.isEmpty(src)) {\n            return false;\n        }\n        Matcher m = mobile_pattern.matcher(src);\n        return m.matches();\n    }\n\n    @Override\n    public void initialize(IsMobile constraintAnnotation) {\n        required = constraintAnnotation.isRequired();\n    }\n\n    @Override\n    public boolean isValid(String phone, ConstraintValidatorContext constraintValidatorContext) {\n        //是否为手机号的实现\n        if (required) {\n            return isMobile(phone);\n        } else {\n            if (StringUtils.isEmpty(phone)) {\n                return true;\n            } else {\n                return isMobile(phone);\n            }\n        }\n    }\n    \n}\n')])])]),a("p",[n._v("3、测试自定义注解的功能")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('@Data\npublic class User {\n    @NotNull\n    @Size(min=2, max=30,message = "请检查名字的长度是否有问题")\n    private String name;\n\n    @NotNull\n    @Min(18)\n    private Integer age;\n\n    //这里是新添加的注解奥\n    @IsMobile\n    private String phone;\n}\n')])])]),a("h2",{attrs:{id:"额外"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#额外"}},[n._v("#")]),n._v(" 额外")]),n._v(" "),a("p",[n._v("也可以通过方法的校验。")]),n._v(" "),a("ul",[a("li",[n._v("控制器上添加@Validated注解")]),n._v(" "),a("li",[n._v("在控制器的方法上添加校验注解，@Min，@Max等。")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('@Validated\n@RestController\n@SpringBootApplication\npublic class UserApplication{\n    public static void main(String[] args) {\n        SpringApplication.run(UserApplication.class,args);\n    }\n\n    @RequestMapping("/test2")\n    public String test2(\n            @IsMobile String phone\n\n    ){\n        return phone + "ok";\n    }\n\n    @ExceptionHandler(ConstraintViolationException.class)\n    @ResponseBody\n    public Object handleConstraintViolationException(ConstraintViolationException cve){\n\n        HashSet<String> messageSet = new HashSet();\n        for (ConstraintViolation constraintViolation : cve.getConstraintViolations()) {\n            messageSet.add(constraintViolation.getMessage());\n        }\n        return messageSet;\n    }\n\n}\n')])])]),a("h2",{attrs:{id:"最后"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#最后"}},[n._v("#")]),n._v(" 最后")]),n._v(" "),a("p",[n._v("通过使用校验器，所有的控制器，我们都不用再去做校验啦，代码再回看是不是清爽很多。我们写代码很简答，但是一定要想到如何把代码写的更简单，更清晰，更利于维护，写重复的代码是在浪费自己的时间奥。")]),n._v(" "),a("p",[n._v("以后再碰到参数校验的情况，首先想到的不是直接就去校验，可以查找自己是否写过某一类的验证器，可以直接拿来即用。")])])}),[],!1,null,null,null);t.default=i.exports}}]);